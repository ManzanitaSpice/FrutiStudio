# Diagnóstico técnico completo del flujo de instancias, loaders y catálogos (Fruti Launcher)

## Estado actual investigado

Se revisó el flujo de extremo a extremo desde frontend (servicios TS) y backend (Tauri/Rust):

1. **Crear instancia**
   - Frontend manda `create_instance` con `id`, `name`, `version`, `loaderName`, `loaderVersion`.
   - Backend guarda registro SQLite y escribe `instance.json`.

2. **Bootstrap runtime al preflight/launch**
   - `prepare_instance_runtime` llama `bootstrap_instance_runtime` cuando falta plan o se fuerza reparación.
   - Se descarga:
     - `version_manifest`
     - metadata de versión de Mojang
     - `client.jar`
     - `asset index` + assets
     - libraries
     - profile/instalación loader (Fabric/Quilt/Forge/NeoForge)
   - Se genera `launch-plan.json` y comando final.

3. **Resolver Java**
   - Detección automática de runtimes instalados por `JavaManager`.
   - Verificación por versión mayor requerida según Minecraft.
   - Fallback a `java` en PATH.

4. **Preflight y validación**
   - Se valida classpath, mainClass, rutas, argumentos JVM, Java compatible, integridad de runtime/mods.

5. **Launch + auto reparación**
   - Si el proceso cae al inicio y se detectan firmas típicas (TinyRemapper / metadata loader), ejecuta autorreparación.

---

## Problemas detectados (causas raíz probables)

### 1) Integración con launcher oficial y terceros incompleta

- El flujo estaba centrado en una carpeta aislada por instancia (`instances/<id>/.minecraft`) sin hidratar desde instalaciones válidas existentes.
- Forge/NeoForge frecuentemente dependen de estructura/base de launcher existente (ej. perfiles/versiones base presentes).
- Resultado: instalaciones que no encontraban metadata/versiones esperadas o quedaban inconsistentes.

### 2) Falta de detector de rutas de launcher para compatibilidad tipo Prism/CurseForge

- No existía comando explícito para detectar rutas estándar de:
  - Minecraft Launcher oficial
  - Prism Launcher
  - CurseForge
- Esto impedía tomar decisiones automáticas de “usar instalación existente como fuente base”.

### 3) Falta de detector explícito de mods instalados por instancia

- Había escaneo por fingerprints CurseForge y validación interna, pero faltaba un comando simple y directo para inventario de mods instalados por instancia con hint de loader.
- Esto dificulta diagnóstico rápido cuando la instancia falla por mods incompatibles.

### 4) Fallos típicos de loader en campo real

- **Fabric/Quilt**: errores de metadata (`McVersionLookup`) o `TinyRemapper` por jars incompletos/corruptos.
- **Forge/NeoForge**: fallas por preflight incompleto o perfil no resuelto, además de diferencias de IDs/versiones.
- **Vanilla**: fallos cuando faltan archivos base por descargas parciales y cachés corruptos.

### 5) Catálogos y descargas de contenido (mods/modpacks/shaders/resourcepacks)

- El pipeline de catálogos mezcla múltiples fuentes (Modrinth/CurseForge/proxies).
- Riesgos identificados:
  - dependencia de proxies para CurseForge sin API key;
  - enlaces de descarga no siempre disponibles por políticas del proveedor;
  - variaciones por categoría/tipo (`project_type`, `classId`) que exigen mapeos robustos.

---

## Re-implementación aplicada en este ciclo

Se implementó hardening real del flujo actual (sin romper la arquitectura existente):

### A) Detector de launchers instalados (nuevo comando)

Se añadió detección automática multiplataforma de rutas típicas:

- `MINECRAFT_HOME` (si existe)
- Minecraft oficial
- Prism Launcher
- CurseForge

con metadato:

- `launcher`
- `root`
- `kind`
- `usable` (si la estructura detectada es utilizable)

### B) Hidratación automática desde launcher detectado

Antes de descargar todo desde cero, ahora el bootstrap intenta reutilizar archivos base existentes cuando están disponibles:

- `versions/<mcVersion>/<mcVersion>.json`
- `versions/<mcVersion>/<mcVersion>.jar`
- `launcher_profiles.json`

Esto reduce fallos de bootstrap, mejora compatibilidad con instalaciones ya funcionales y acerca el comportamiento a launchers maduros.

### C) Detector de mods instalados por instancia (nuevo comando)

Se añadió comando para inventariar mods `.jar` en `mods/` con:

- nombre de archivo
- ruta
- tamaño
- `loader_hint` (fabric/quilt/forge/neoforge/unknown) usando detección por contenido

### D) Exposición frontend de nuevas capacidades

Se añadieron funciones en `instanceService.ts` para:

- detectar launchers (`detectMinecraftLaunchers`)
- detectar mods instalados (`detectInstalledMods`)

Esto permite cablear diagnósticos en panel de instancias sin volver a tocar backend.

---

## Qué puede seguir fallando (debug preventivo)

### 1) Java incorrecto aunque exista runtime

- Si hay varios Java, puede elegirse uno “compatible por major” pero no ideal por vendor/build.
- Recomendación: priorizar Temurin/Adoptium y fijar runtime por instancia.

### 2) Modloader versión “latest” inestable temporalmente

- En ventanas de publicación, `latest` puede resolver una versión recién subida con dependencias no propagadas aún.
- Recomendación: permitir “pin” explícito recomendado y fallback automático a la penúltima versión estable.

### 3) Mod incompatibles por loader cruzado

- Aunque exista detector, usuarios mezclan Forge/Fabric/Quilt en la misma instancia.
- Recomendación: bloqueo preventivo por loader al instalar mod y validación previa al launch.

### 4) APIs externas degradadas

- Si Modrinth/CurseForge tienen throttling o cambios de respuesta, el catálogo puede quedar incompleto.
- Recomendación: cache persistente + circuit breaker + telemetría de errores por endpoint.

### 5) Descargas parciales por red

- Ya hay limpieza de `.part` y validaciones, pero conexiones inestables pueden seguir provocando ciclos de reparación.
- Recomendación: exponer UI de “estado detallado de archivo corrupto” y botón de limpieza selectiva.

---

## Plan recomendado inmediato (siguiente iteración)

1. UI de diagnóstico técnico por instancia (timeline + checks + acciones rápidas).
2. Perfil de Java por instancia con selector/manual override.
3. Regla dura: no instalar mod incompatible con loader objetivo.
4. Pin de versiones sugeridas para Forge/NeoForge/Fabric por Minecraft.
5. Mejorar resolución de catálogos con caché persistente y fallback controlado.

---

## Conclusión

El problema no era un único bug, sino un conjunto de brechas de resiliencia en el flujo completo. Con esta re-implementación se cubren puntos críticos que impedían operar de forma estable con Fabric/Forge/NeoForge/Vanilla y se añade infraestructura concreta para depurar instancias rotas con enfoque similar a launchers maduros.
